<!DOCTYPE html>
<html>
  <head>
    <title>Why Kotlin is Terrible</title>
    <meta charset="utf-8">
    <style>
      @import url('https://fonts.googleapis.com/css?family=Fira+Sans:400,800');
      @import url('https://fonts.googleapis.com/css?family=Fira+Mono');

      body { font-family: 'Fira Sans'; }
      h1, h2, h3 {
        font-family: 'Fira Sans';
        font-weight: bold;
      }
      .remark-code, .remark-inline-code { font-family: 'Fira Code','Fira Mono'; }

      .logo { display: block; width: 100%; height: auto;}
      img {max-width: 100%; max-height: 100%; display: block; margin: 0 auto;}
      .center-image { width: 100%; height: 550px; display: block }

      ul {
        font-size: 32px;
      }

      ol {
        font-size: 48px;
      }

      .quiet {
        font-size: 50%
      }

      code {
        color: white;
        background-color: black;
        display: inline-block;
        border-radius: 5px;
        padding: 0 5px;
        margin: 2px 0;
      }

      .remark-code {
        font-size: 22px !important;
      }

      .code-notes ul {
        font-size: 28px;
      }

      .green { color: green; }
      .red { color: red; }

    </style>
  </head>
  <body>
    <textarea id="source">

class: middle, center

# Why Kotlin is Terrible

---

## About Me [(@gypsydave5)](https://twitter.com/gypsydave5)

- Ex philosopher/librarian/marketeer
- Makers Academy graduate (August 2014)
- Full Stack Developer @Acuris ~2.5 years
- SpringerNature for ~3 months
- Addicted to learning new languages

???
In fact, strongly believe that learning other languages helps learn all languages
"Travel broadens the mind"

---
# Agenda

### 0: Kotlin overview
### 1: Variations on `addTwo`
### 2: `let` me Entertain you
### 3: But what _is_ it???

---

class: center, middle

# 0: Kotlin overview

---

## History

- Started in 2010/11
- Open sourced 2012
- Pre-alpha compiler released in 2012
- Google annouces Android support 2017

???

Compare with, say Rust (2006), Clojure (2007), Scala (2004) - much newer.

---
# What is it
.middle[## "Kotlin is a modern statically typed language compilers to JVM byte codes and JavaScript."]

.right[-- Andrey Breslav, Kotlin creator [(source)](https://zeroturnaround.com/rebellabs/jvm-languages-report-extended-interview-with-kotlin-creator-andrey-breslav/)]

---
# Motivation

.middle[### "We've looked at all of the existing JVM languages, and none of them meet our needs. Scala has the right features, but its most obvious deficiency is very slow compilation"]

.right[-- Dmitry Jemerov, JetBrains development lead [(source)](https://www.infoworld.com/article/2622405/java/jetbrains-readies-jvm-based-language.html)]

---

.middle[# "A Better Java"]

.right[-- Andrey Breslav, Kotlin creator [(source)](https://zeroturnaround.com/rebellabs/jvm-languages-report-extended-interview-with-kotlin-creator-andrey-breslav/)]

???

A better Java doesn't mean much to me, having only done five minutes of Java and
gone running to the hills...

---

# 1: Anonymous functions/Lambdas/Blocks

---
## Variation 0: A named function

```kotlin
fun addTwo (number: Int): Int {
  return number + 2
}
```

???

Nothing that exciting here - could _almost_ be writing C. Or Go.

---
## Variation 1: Single-Expression function

```kotlin
fun addTwo (number: Int): Int = number + 2
```

???

Can just assign the result as an expression - much as with Scala

---
## Variation 2: Function reference

# This doesn't work

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(addTwo)
```

# This does

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map(::addTwo)
```

???

"Function reference" - like a pointer in C? Seems mad.

But what if we wanted to inline the above function, like you would with
that ultimate ergonomic functional language...

---
# Javascript

.middle[```javascript
const listOfNumbers = [1, 2, 3, 4]
listOfNumbers.map(number => number + 2)
```]

???

Javscript - hey, it's Scheme in the Browser! Woo hoo.

And we can do much the same with Kotlin.

---
## Variation 3: Lambda!

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map({number -> number + 2})
```

???

Kotlin looks about the same - the arrow lost some weight. This syntax is called
a Lambda, much the same as it's called in Python (or even Java these days).

The Lambdas look kinda like they do in Groovy, right? So lets use that good old
`block` syntax from Groovy - from Ruby (from Smalltalk ultimately).

---
## Variation 4: no parens for 'block'

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { number -> number + 2 }
```

???

Hey, and does anyone remember `it` from Groovy? Well if there's only one
argument to the ~anonymous function~ Lambda, we'll just call it `it`

---
## Variation 5: with `it`

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { it + 2 }
```

---
class: middle, center
## Variations so far: 5

???

So, we're up to five variations so far... but it's far from over...

---
## The point of no `return`...

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map({number -> number + 2})
```

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { number -> number + 2 }
```

```kotlin
val listOfNumbers = listOf(1, 2, 3, 4)
listOfNumbers.map { it + 2 }

```

???

You may have noticed that the Lambdas have no return. That's because,
like in Rust or Ruby or Scheme or Common Lisp or whatever, they evaluate to
their last expression.

What if you _do_ want to return? Say a nice early return if you meet some
condition...

---
class: center, middle
# Pro tip: Don't return
---

```kotlin
fun addTwoIfThree(numbers: List<Int>): List<Int> {
  return numbers.map {
    if (it == 3) {
      return it + 2 // return bound to `addTwoIfThree`
    }
    return it
  }
}
```

This will fail to compile (`Int` is not a `List<Int>`)

???
So this doesn't work because `return` is bound to the outer, named function. We
could make this work by using the `if` as an expression (it is an expression),
but if we were severely wedded to `return` - maybe we took too much C as kids -
there is a way..

---
```
fun addTwoIfThree(numbers: List<Int>): List<Int> {
    return numbers.map { it ->
        if (it == 3) {
            return@map it + 2
        }
        return@map it
    }
}
```

???
We can add a named return with `return@map` - this tells the Lambda where to
bind the return to - in this case the `map`. Problem solved.

But wait... isn't this confusing? What if I wanted a _real_ return?

---

---
class: center, middle
# Questions?
---
class: center, middle
# Thank You!
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'monokai',
        highlightLines: true,
        slideNumberFormat: '',
        navigation: {
          scroll: false,
        }
      });
    </script>
  </body>
</html>
